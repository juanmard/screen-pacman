// Code generated by Icestudio 0.3.3-rc
// Thu, 26 Jul 2018 17:42:54 GMT

`default_nettype none

module main #(
 parameter vc429e4 = 62,
 parameter v3c2ffb = 3'b100
) (
 input v60e8e8,
 input vclk,
 output v5232a0,
 output vd9235d,
 output vabb3e2,
 output ved4d00,
 output v30c483,
 output v51d5fd,
 output ve9bd5e
);
 localparam p5 = v3c2ffb;
 localparam p6 = vc429e4;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:22] w7;
 wire w8;
 wire w9;
 wire [0:25] w10;
 wire [0:22] w11;
 wire w12;
 wire w13;
 wire [0:25] w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:7] w18;
 wire [0:7] w19;
 wire w20;
 wire w21;
 wire w22;
 wire w23;
 wire w24;
 assign ved4d00 = w0;
 assign vd9235d = w1;
 assign v5232a0 = w2;
 assign vabb3e2 = w3;
 assign v30c483 = w4;
 assign v51d5fd = w13;
 assign ve9bd5e = w16;
 assign w17 = v60e8e8;
 assign w21 = vclk;
 assign w22 = vclk;
 assign w23 = vclk;
 assign w24 = vclk;
 assign w9 = w8;
 assign w11 = w7;
 assign w22 = w21;
 assign w23 = w21;
 assign w23 = w22;
 assign w24 = w21;
 assign w24 = w22;
 assign w24 = w23;
 v7d29b1 v063e26 (
  .v706449(w0),
  .v2bfeec(w1),
  .v88adbc(w2),
  .vd7ac4a(w3),
  .vdb6628(w4),
  .v879a71(w14)
 );
 ve304dc #(
  .va5f5b2(p6)
 ) v9d4710 (
  .v61abb6(w7),
  .v6f78a5(w8),
  .vd91ab0(w21)
 );
 v6663b8 #(
  .vb8d3ae(p5)
 ) v287eca (
  .vca3201(w7),
  .v1bb1ad(w8),
  .v2761a5(w10)
 );
 v429fbc v1c38a6 (
  .vdf4472(w11),
  .v32d6d9(w12)
 );
 v20ddb4 v3892ad (
 
 );
 vc4dd08 vfec004 (
  .v608bd9(w15)
 );
 vf8a63b ve09c26 (
  .v129887(w17),
  .vb9ff0a(w18),
  .va8a6b1(w20),
  .v2cc5f5(w22)
 );
 main_veaf5aa veaf5aa (
  .data(w18),
  .control(w19),
  .rcv(w20)
 );
 v8b89a5 v110163 (
  .vb55943(w23)
 );
 vdca2de vd98389 (
  .vdd1857(w9),
  .ve87cf9(w10),
  .v0d69f5(w12),
  .v0631b4(w13),
  .v16dd7b(w14),
  .v02d3c7(w15),
  .v282aa4(w16),
  .vaab52b(w19),
  .vc9e12a(w24)
 );
endmodule

module v7d29b1 (
 input [25:0] v879a71,
 output v88adbc,
 output v2bfeec,
 output vd7ac4a,
 output v706449,
 output vdb6628
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire w4;
 wire [0:25] w5;
 assign v88adbc = w0;
 assign v2bfeec = w1;
 assign vd7ac4a = w2;
 assign v706449 = w3;
 assign vdb6628 = w4;
 assign w5 = v879a71;
 v7d29b1_vbebd3d vbebd3d (
  .VSync(w0),
  .HSync(w1),
  .Red(w2),
  .Green(w3),
  .Blue(w4),
  .RGBStr_i(w5)
 );
endmodule

module v7d29b1_vbebd3d (
 input [25:0] RGBStr_i,
 output VSync,
 output HSync,
 output Red,
 output Green,
 output Blue
);
 // @include Pxs.vh
 // @include PxsVGAComp.v
 
 
 //-- Instantiate  PxsVGAComp module.
 PxsVGAComp 
  PxsVGAComp1(
 			RGBStr_i,	// HSync, VSync, XCoord, YCoord, ActiveVideo, RGB(1:1:1)
             HSync,      // Horizontal sync out
             VSync,      // Vertical sync out
             Red,        // RED vga output
             Green,      // GREEN vga output
             Blue        // BLUE vga output
     );
 
endmodule

module ve304dc #(
 parameter va5f5b2 = 62
) (
 input vd91ab0,
 output v6f78a5,
 output [22:0] v61abb6
);
 localparam p8 = va5f5b2;
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:22] w4;
 wire w5;
 wire [0:9] w6;
 wire [0:9] w7;
 assign w0 = vd91ab0;
 assign v6f78a5 = w1;
 assign v61abb6 = w4;
 v691d98 v76bfc0 (
  .v7964d5(w2),
  .v2fd51b(w3),
  .vcd0644(w4),
  .v372172(w5),
  .vf2cc41(w6),
  .v1f8542(w7)
 );
 vb78b9d #(
  .v8ad028(p8)
 ) v118e86 (
  .v7dbbbb(w0),
  .v9987be(w1),
  .v501546(w2),
  .vcbba55(w3),
  .v83ac33(w5),
  .v8a68e1(w6),
  .vf3ae84(w7)
 );
endmodule

module v691d98 (
 input v2fd51b,
 input v372172,
 input v7964d5,
 input [9:0] vf2cc41,
 input [9:0] v1f8542,
 output [22:0] vcd0644
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:9] w3;
 wire [0:9] w4;
 wire [0:22] w5;
 assign w0 = v2fd51b;
 assign w1 = v372172;
 assign w2 = v7964d5;
 assign w3 = vf2cc41;
 assign w4 = v1f8542;
 assign vcd0644 = w5;
 v691d98_vbebd3d vbebd3d (
  .VSync(w0),
  .HSync(w1),
  .ActiveVideo(w2),
  .XCoord(w3),
  .YCoord(w4),
  .VGAStr(w5)
 );
endmodule

module v691d98_vbebd3d (
 input VSync,
 input HSync,
 input ActiveVideo,
 input [9:0] XCoord,
 input [9:0] YCoord,
 output [22:0] VGAStr
);
 // @include PxsStrVGAJoin.v
 
 
 //-- Instantiate PxsStrVGAJoin module.
 PxsStrVGAJoin 
 PxsStrVGAJoin1(
 	HSync,         // Horizontal sync out
     VSync,         // Vertical sync out
     XCoord,          // ScanX postion
     YCoord,          // ScanY position 
     ActiveVideo,
 	VGAStr	// HSync, VSync, XCoord, YCoord, ActiveVideo, RGB(1:1:1)
     );
 
endmodule

module vb78b9d #(
 parameter v8ad028 = 62
) (
 input v7dbbbb,
 output v9987be,
 output vcbba55,
 output v83ac33,
 output v501546,
 output [9:0] v8a68e1,
 output [9:0] vf3ae84
);
 localparam p1 = v8ad028;
 wire w0;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire [0:9] w6;
 wire [0:9] w7;
 assign w0 = v7dbbbb;
 assign v9987be = w2;
 assign vcbba55 = w3;
 assign v83ac33 = w4;
 assign v501546 = w5;
 assign v8a68e1 = w6;
 assign vf3ae84 = w7;
 vb78b9d_vb4a5e4 #(
  .FDivider(p1)
 ) vb4a5e4 (
  .clk(w0),
  .px_clk(w2),
  .vsync(w3),
  .hsync(w4),
  .activevideo(w5),
  .x_px(w6),
  .y_px(w7)
 );
endmodule

module vb78b9d_vb4a5e4 #(
 parameter FDivider = 0
) (
 input clk,
 output px_clk,
 output vsync,
 output hsync,
 output activevideo,
 output [9:0] x_px,
 output [9:0] y_px
);
 // @include VGASyncGen.v
 
 
 //-- Instantiate VgaSyncGenr module.
 VGASyncGen #(FDivider)
 VGASyncGen1 (
     clk,                // System clock.
     hsync,              // Horizontal syncro.
     vsync,              // Vertical syncro.
     x_px,               // Actual x pixel.
     y_px,               // Actual y pixel.
     activevideo,        // Active video.
     px_clk              // Pixel clock 31.5Mhz (PLL).
     );
 
endmodule

module v6663b8 #(
 parameter vb8d3ae = 3'b001
) (
 input v1bb1ad,
 input [22:0] vca3201,
 output [25:0] v2761a5
);
 localparam p3 = vb8d3ae;
 wire w0;
 wire [0:25] w1;
 wire [0:22] w2;
 assign w0 = v1bb1ad;
 assign v2761a5 = w1;
 assign w2 = vca3201;
 v6663b8_vbebd3d #(
  .color(p3)
 ) vbebd3d (
  .px_clk(w0),
  .RGBStr_o(w1),
  .VGAStr_i(w2)
 );
endmodule

module v6663b8_vbebd3d #(
 parameter color = 0
) (
 input px_clk,
 input [22:0] VGAStr_i,
 output [25:0] RGBStr_o
);
 // @include PxsConstant.v
 
 
 //-- Instantiate PxsConstant module.
 PxsConstant #(
 .color(color)
 )
 PxsConstant1(
     px_clk,
     VGAStr_i,
     RGBStr_o
     );
 
endmodule

module v429fbc #(
 parameter vcbc232 = 640,
 parameter vd99934 = 480
) (
 input [22:0] vdf4472,
 output v32d6d9
);
 localparam p2 = vcbc232;
 localparam p3 = vd99934;
 wire w0;
 wire [0:22] w1;
 assign v32d6d9 = w0;
 assign w1 = vdf4472;
 v429fbc_v0c69d3 #(
  .width_screen(p2),
  .height_screen(p3)
 ) v0c69d3 (
  .endframe(w0),
  .VGAStr_i(w1)
 );
endmodule

module v429fbc_v0c69d3 #(
 parameter width_screen = 0,
 parameter height_screen = 0
) (
 input [22:0] VGAStr_i,
 output endframe
);
 // Alias in stream.
 `define XC 22:13
 `define YC 12:3
 
 // Check endframe.
 assign  endframe = ((VGAStr_i[`XC]==width_screen-1) && (VGAStr_i[`YC]==height_screen-1)) ? 1'b1 : 1'b0;
 
endmodule

module v20ddb4 #(
 parameter v1c486c = 16
) (
 input v1bb1ad,
 input [25:0] v879a71,
 output [25:0] v2761a5
);
 localparam p3 = v1c486c;
 wire [0:25] w0;
 wire w1;
 wire [0:25] w2;
 assign w0 = v879a71;
 assign w1 = v1bb1ad;
 assign v2761a5 = w2;
 v20ddb4_vbebd3d #(
  .size(p3)
 ) vbebd3d (
  .RGBStr_i(w0),
  .px_clk(w1),
  .RGBStr_o(w2)
 );
endmodule

module v20ddb4_vbebd3d #(
 parameter size = 0
) (
 input px_clk,
 input [25:0] RGBStr_i,
 output [25:0] RGBStr_o
);
 // @include Pxs.vh
 // @include PxsGrid.v
 
 PxsGrid 
 #(
 .size(size)
 )
 PxsGrid01
 (
     px_clk,
     RGBStr_i,
     RGBStr_o
 );
 
endmodule

module vc4dd08 (
 output v608bd9
);
 wire w0;
 assign v608bd9 = w0;
 vc4dd08_v68c173 v68c173 (
  .v(w0)
 );
endmodule

module vc4dd08_v68c173 (
 output v
);
 // Bit 0
 
 assign v = 1'b0;
endmodule

module vf8a63b (
 input v2cc5f5,
 input v129887,
 output va8a6b1,
 output [7:0] vb9ff0a
);
 wire w0;
 wire [0:7] w1;
 wire [0:7] w2;
 wire [0:9] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 assign w0 = v129887;
 assign vb9ff0a = w1;
 assign va8a6b1 = w6;
 assign w8 = v2cc5f5;
 assign w9 = v2cc5f5;
 assign w10 = v2cc5f5;
 assign w11 = v2cc5f5;
 assign w14 = v2cc5f5;
 assign w9 = w8;
 assign w10 = w8;
 assign w10 = w9;
 assign w11 = w8;
 assign w11 = w9;
 assign w11 = w10;
 assign w12 = w7;
 assign w14 = w8;
 assign w14 = w9;
 assign w14 = w10;
 assign w14 = w11;
 assign w15 = w4;
 v5d56f1 vfa7fb3 (
  .v74a653(w0),
  .vc6ae1f(w7),
  .vd7ce19(w10)
 );
 vb66984 v3527f2 (
  .v426b31(w2),
  .v25b980(w3)
 );
 v239306 vfb3110 (
  .v02ed6f(w1),
  .va3ae6b(w2),
  .va31c0f(w11),
  .vc21fb3(w13)
 );
 v1c3bf0 v1e089e (
  .v577640(w3),
  .ve9e73c(w12),
  .v9a7ca3(w14),
  .v9cf23f(w15)
 );
 vdd29f1 v42c967 (
  .vdfd85c(w4),
  .va119a9(w5),
  .vcea413(w8)
 );
 v9c7988 v8d7ef7 (
  .vf759b2(w4),
  .vab7795(w5),
  .v184932(w6),
  .va431f5(w7),
  .v00dabd(w9),
  .vdd5660(w13)
 );
endmodule

module v5d56f1 (
 input vd7ce19,
 input v74a653,
 output vc6ae1f
);
 wire w0;
 wire w1;
 wire w2;
 assign vc6ae1f = w0;
 assign w1 = vd7ce19;
 assign w2 = v74a653;
 vf031e4 v53b48b (
  .vc6ae1f(w0),
  .vd7ce19(w1),
  .v74a653(w2)
 );
endmodule

module vf031e4 #(
 parameter vab1fa2 = 1
) (
 input vd7ce19,
 input v74a653,
 output vc6ae1f
);
 localparam p0 = vab1fa2;
 wire w1;
 wire w2;
 wire w3;
 assign w1 = vd7ce19;
 assign w2 = v74a653;
 assign vc6ae1f = w3;
 v7bd255 #(
  .v38488b(p0)
 ) v4746ff (
  .vb55943(w1),
  .vef4cea(w2),
  .vc24d9f(w3)
 );
endmodule

module v7bd255 #(
 parameter v38488b = 0
) (
 input vb55943,
 input vef4cea,
 output vc24d9f
);
 localparam p3 = v38488b;
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vef4cea;
 assign w1 = vb55943;
 assign vc24d9f = w2;
 v7bd255_v526aa2 #(
  .DINI(p3)
 ) v526aa2 (
  .d(w0),
  .clk(w1),
  .q(w2)
 );
endmodule

module v7bd255_v526aa2 #(
 parameter DINI = 0
) (
 input clk,
 input d,
 output q
);
 // D flip-flop
 // parameter DINI = 0;
 
 reg q = DINI;
 
 always @(posedge clk)
 begin
   q <= d;
 end
 
 
endmodule

module vb66984 (
 input [9:0] v25b980,
 output v2df079,
 output [7:0] v426b31,
 output v1e375b
);
 wire [0:7] w0;
 wire w1;
 wire w2;
 wire [0:9] w3;
 assign v426b31 = w0;
 assign v2df079 = w1;
 assign v1e375b = w2;
 assign w3 = v25b980;
 vb66984_v8e4e19 v8e4e19 (
  .o(w0),
  .H(w1),
  .L(w2),
  .i(w3)
 );
endmodule

module vb66984_v8e4e19 (
 input [9:0] i,
 output H,
 output [7:0] o,
 output L
);
 assign o = i[8:1];
endmodule

module v239306 (
 input va31c0f,
 input vc21fb3,
 input [7:0] va3ae6b,
 output [7:0] v02ed6f
);
 wire [0:7] w0;
 wire [0:7] w1;
 wire w2;
 wire w3;
 assign w0 = va3ae6b;
 assign v02ed6f = w1;
 assign w2 = va31c0f;
 assign w3 = vc21fb3;
 v239306_va6d58d va6d58d (
  .di(w0),
  .do(w1),
  .clk(w2),
  .load(w3)
 );
endmodule

module v239306_va6d58d (
 input clk,
 input load,
 input [7:0] di,
 output [7:0] do
);
 reg [7:0] do = 8'h00;
 
 always @(posedge clk)
   if (load)
     do <= di;
endmodule

module v1c3bf0 (
 input v9a7ca3,
 input v9cf23f,
 input ve9e73c,
 output [9:0] v577640
);
 wire w0;
 wire w1;
 wire w2;
 wire [0:9] w3;
 assign w0 = v9a7ca3;
 assign w1 = v9cf23f;
 assign w2 = ve9e73c;
 assign v577640 = w3;
 v1c3bf0_v2b88be v2b88be (
  .clk(w0),
  .clk_baud(w1),
  .ser_in(w2),
  .data(w3)
 );
endmodule

module v1c3bf0_v2b88be (
 input clk,
 input clk_baud,
 input ser_in,
 output [9:0] data
);
 reg [9:0] raw_data = 10'h0;
 
 
 always @(posedge clk)
   if (clk_baud == 1)
     raw_data <= {ser_in, raw_data[9:1]};
     
 assign data = raw_data;
endmodule

module vdd29f1 (
 input vcea413,
 input va119a9,
 output vdfd85c
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vcea413;
 assign w1 = va119a9;
 assign vdfd85c = w2;
 vdd29f1_vae58ad vae58ad (
  .clk(w0),
  .clk_ena(w1),
  .clk_out(w2)
 );
endmodule

module vdd29f1_vae58ad (
 input clk,
 input clk_ena,
 output clk_out
);
 //-- Constants for obtaining standard BAURATES:
 `define B115200 139 //16Mhz
 `define B57600  208
 `define B38400  313
 
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 
 localparam BAUDRATE = `B115200;
 
 //-- Number of bits needed for storing the baudrate divisor
 localparam N = $clog2(BAUDRATE);
 
 //-- Value for generating the pulse in the middle of the period
 localparam M2 = (BAUDRATE >> 1);
 
 //-- Counter for implementing the divisor (it is a BAUDRATE module counter)
 //-- (when BAUDRATE is reached, it start again from 0)
 reg [N-1:0] divcounter = 0;
 
 //-- Contador módulo M
 always @(posedge clk)
 
   if (clk_ena)
     //-- Normal working: counting. When the maximum count is reached, it starts from 0
     divcounter <= (divcounter == BAUDRATE - 1) ? 0 : divcounter + 1;
   else
     //-- Counter fixed to its maximum value
     //-- When it is resumed it start from 0
     divcounter <= BAUDRATE - 1;
 
 //-- The output is 1 when the counter is in the middle of the period, if clk_ena is active
 //-- It is 1 only for one system clock cycle
 assign clk_out = (divcounter == M2) ? clk_ena : 0;
endmodule

module v9c7988 (
 input v00dabd,
 input vf759b2,
 input va431f5,
 output vab7795,
 output v184932,
 output vdd5660
);
 wire w0;
 wire [0:3] w1;
 wire w2;
 wire w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 assign w2 = vf759b2;
 assign w3 = v00dabd;
 assign w4 = v00dabd;
 assign vab7795 = w5;
 assign v184932 = w6;
 assign vdd5660 = w7;
 assign w8 = va431f5;
 assign w4 = w3;
 vbfd6e2 v378cee (
  .v43dc18(w0),
  .v4dac78(w1),
  .va7f01e(w2),
  .v7b4936(w4)
 );
 v9c7988_va3d07e va3d07e (
  .clear(w0),
  .bitc(w1),
  .clk(w3),
  .bauden(w5),
  .rcv(w6),
  .load(w7),
  .rx_r(w8)
 );
endmodule

module v9c7988_va3d07e (
 input clk,
 input [3:0] bitc,
 input rx_r,
 output clear,
 output bauden,
 output rcv,
 output load
);
 //-------------------------------------------
 //-- CONTROLLER  (Finite state machine)
 //-------------------------------------------
 
 //-- Receiver states
 localparam IDLE = 2'd0;  //-- IDLEde reposo
 localparam RECV = 2'd1;  //-- Receiving data
 localparam LOAD = 2'd2;  //-- Storing the character received
 localparam DAV = 2'd3;   //-- Data is available
 
 //-- Control signals
 reg bauden = 0;  //-- Enable the baud generator
 reg clear = 0;   //-- Clear the bit counter
 reg load = 0;    //-- Load the received character into the data register
 reg rcv;
 
 //-- fsm states
 reg [1:0] state = IDLE;
 reg [1:0] next_state;
 
 //-- Transition between states
 always @(posedge clk)
     state <= next_state;
 
 //-- Control signal generation and next states
 always @(*) begin
 
   //-- Default values
   next_state = state;      //-- Stay in the same state by default
   bauden = 0;
   clear = 0;
   load = 0;
 
   case(state)
 
     //-- Idle state
     //-- Remain in this state until a start bit is received in rx_r
     IDLE: begin
       clear = 1;
       rcv = 0;
       if (rx_r == 0)
         next_state = RECV;
     end
 
     //-- Receiving state
     //-- Turn on the baud generator and wait for the serial package to be received
     RECV: begin
       bauden = 1;
       rcv = 0;
       if (bitc == 4'd10)
         next_state = LOAD;
     end
 
     //-- Store the received character in the data register (1 cycle)
     LOAD: begin
       load = 1;
       rcv = 0;
       next_state = DAV;
     end
 
     //-- Data Available (1 cycle)
     DAV: begin
       rcv = 1;
       next_state = IDLE;
     end
 
     default:
       rcv = 0;
 
   endcase
 
 end
 
endmodule

module vbfd6e2 (
 input v7b4936,
 input v43dc18,
 input va7f01e,
 output [3:0] v4dac78
);
 wire [0:3] w0;
 wire w1;
 wire w2;
 wire w3;
 assign v4dac78 = w0;
 assign w1 = v7b4936;
 assign w2 = v43dc18;
 assign w3 = va7f01e;
 vbfd6e2_vf1519a vf1519a (
  .bitc(w0),
  .clk(w1),
  .rst(w2),
  .clk_baud(w3)
 );
endmodule

module vbfd6e2_vf1519a (
 input clk,
 input rst,
 input clk_baud,
 output [3:0] bitc
);
 reg [3:0] _bitc = 0;
 
 always @(posedge clk)
   if (rst)
     _bitc <= 4'd0;
   else if (rst == 0 && clk_baud == 1)
     _bitc <= _bitc + 1;
     
     assign bitc = _bitc;
 
endmodule

module v8b89a5 (
 input vb55943,
 input vef4cea,
 output vc24d9f
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = vef4cea;
 assign w1 = vb55943;
 assign vc24d9f = w2;
 v8b89a5_v526aa2 v526aa2 (
  .d(w0),
  .clk(w1),
  .q(w2)
 );
endmodule

module v8b89a5_v526aa2 (
 input clk,
 input d,
 output q
);
 // D flip-flop
 
 reg q = 1'b0;
 
 always @(posedge clk)
 begin
   q <= d;
 end
 
 
endmodule

module vdca2de (
 input vdd1857,
 input [25:0] ve87cf9,
 input v0d69f5,
 input v02d3c7,
 input [7:0] vaab52b,
 input vc9e12a,
 output [25:0] v16dd7b,
 output v0631b4,
 output v282aa4
);
 wire w0;
 wire [0:25] w1;
 wire [0:25] w2;
 wire w3;
 wire w4;
 wire [0:5] w5;
 wire [0:5] w6;
 wire w7;
 wire w8;
 wire [0:7] w9;
 wire w10;
 wire w11;
 wire [0:1] w12;
 wire w13;
 wire [0:7] w14;
 wire w15;
 wire w16;
 wire w17;
 wire [0:7] w18;
 wire w19;
 wire w20;
 wire w21;
 wire [0:7] w22;
 wire w23;
 wire w24;
 wire w25;
 wire w26;
 wire w27;
 wire w28;
 assign w0 = vdd1857;
 assign w1 = ve87cf9;
 assign v16dd7b = w2;
 assign w3 = v0d69f5;
 assign w7 = vdd1857;
 assign w8 = v02d3c7;
 assign v0631b4 = w10;
 assign w13 = vc9e12a;
 assign v282aa4 = w20;
 assign w21 = vdd1857;
 assign w22 = vaab52b;
 assign w7 = w0;
 assign w21 = w0;
 assign w21 = w7;
 v30a619 v5196f5 (
  .vb6af5d(w10),
  .vff0413(w11),
  .v0c83ba(w12),
  .v25d2dc(w13)
 );
 v27b161 v76a631 (
  .vdd1857(w0),
  .ve87cf9(w1),
  .v16dd7b(w2),
  .v0d69f5(w4),
  .v508a28(w5),
  .v26d0c3(w6),
  .v5f213f(w9),
  .ve94c8f(w14),
  .v86d7a2(w15),
  .v52218c(w16)
 );
 v4ee1dc v540996 (
  .v3c7b5b(w17),
  .v4251e6(w18),
  .v38a546(w19),
  .vb37ae4(w20),
  .v9f94eb(w21)
 );
 vdca2de_v46d7ed v46d7ed (
  .dyn_clk(w3),
  .update(w4),
  .posx(w5),
  .posy(w6),
  .px_clk(w7),
  .rst(w8),
  .sprite(w9),
  .mute(w11),
  .sound(w12),
  .read_sprite(w14),
  .get(w15),
  .ready(w16),
  .start(w17),
  .serial_out(w18),
  .serial_recive(w19),
  .left(w23),
  .up(w24),
  .down(w25),
  .btn1(w26),
  .btn2(w27),
  .right(w28)
 );
 vdca2de_va8c715 va8c715 (
  .control(w22),
  .left(w23),
  .up(w24),
  .down(w25),
  .btn1(w26),
  .btn2(w27),
  .right(w28)
 );
endmodule

module vdca2de_v46d7ed (
 input px_clk,
 input dyn_clk,
 input rst,
 input left,
 input right,
 input up,
 input down,
 input btn1,
 input btn2,
 input [7:0] read_sprite,
 input ready,
 input serial_recive,
 output [7:0] sprite,
 output update,
 output [5:0] posx,
 output [5:0] posy,
 output get,
 output mute,
 output [1:0] sound,
 output start,
 output [7:0] serial_out
);
 //@include TestCodeB.v
 
 TestCodeB
 TestCodeB_01
 (
     px_clk,
     dyn_clk,
     rst,
     left,
     right,
     up,
     down,
     btn1,
     btn2,
     read_sprite,
     sprite,
     update,
     posx,
     posy,
     get,
     mute,
     sound,
     ready,
     serial_recive,
     start,
     serial_out
 );
endmodule

module vdca2de_va8c715 (
 input [7:0] control,
 output left,
 output right,
 output up,
 output down,
 output btn1,
 output btn2
);
 assign left  = control[5];
 assign right = control[4];
 assign up    = control[3];
 assign down  = control[2];
 assign btn1  = control[1];
 assign btn2  = control[0];
endmodule

module v30a619 #(
 parameter v1239e1 = 17,
 parameter v04c545 = 19,
 parameter va166e2 = 15
) (
 input v25d2dc,
 input vff0413,
 input [1:0] v0c83ba,
 output vb6af5d,
 output va7d572
);
 localparam p1 = va166e2;
 localparam p3 = v1239e1;
 localparam p5 = v04c545;
 wire w0;
 wire w2;
 wire w4;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 wire w20;
 wire [0:1] w21;
 assign w0 = v25d2dc;
 assign w7 = v25d2dc;
 assign w8 = v25d2dc;
 assign w16 = vff0413;
 assign vb6af5d = w17;
 assign va7d572 = w18;
 assign w21 = v0c83ba;
 assign w7 = w0;
 assign w8 = w0;
 assign w8 = w7;
 assign w18 = w17;
 v435b29 #(
  .v100e1b(p1)
 ) va24b71 (
  .v0daa9e(w0),
  .v2efea4(w2)
 );
 v11a6f4 ve97e25 (
  .v0e28cb(w2),
  .v3ca442(w9),
  .vcbab45(w12)
 );
 v435b29 #(
  .v100e1b(p3)
 ) v4acc98 (
  .v2efea4(w4),
  .v0daa9e(w7)
 );
 v11a6f4 vb6ceeb (
  .v0e28cb(w4),
  .v3ca442(w10),
  .vcbab45(w13)
 );
 v435b29 #(
  .v100e1b(p5)
 ) vd2f8c7 (
  .v2efea4(w6),
  .v0daa9e(w8)
 );
 v11a6f4 v0266b4 (
  .v0e28cb(w6),
  .v3ca442(w11),
  .vcbab45(w14)
 );
 v2fa1b5 v04699a (
  .v0e28cb(w12),
  .v3ca442(w13),
  .vcbab45(w15)
 );
 v2fa1b5 vefd2d7 (
  .v3ca442(w14),
  .v0e28cb(w15),
  .vcbab45(w20)
 );
 v11a6f4 va84315 (
  .vcbab45(w17),
  .v3ca442(w19),
  .v0e28cb(w20)
 );
 v32200d v293735 (
  .v0e28cb(w16),
  .vcbab45(w19)
 );
 v30a619_v54dc66 v54dc66 (
  .ping(w9),
  .pong(w10),
  .goal(w11),
  .sound(w21)
 );
endmodule

module v30a619_v54dc66 (
 input [1:0] sound,
 output ping,
 output pong,
 output goal
);
 assign ping = (sound == 1) ? 1'b1 : 1'b0;
 assign pong = (sound == 2) ? 1'b1 : 1'b0;
 assign goal = (sound == 3) ? 1'b1 : 1'b0;
endmodule

module v435b29 #(
 parameter v100e1b = 22
) (
 input v0daa9e,
 output v2efea4
);
 localparam p2 = v100e1b;
 wire w0;
 wire w1;
 assign v2efea4 = w0;
 assign w1 = v0daa9e;
 v435b29_vac7386 #(
  .N(p2)
 ) vac7386 (
  .clk_out(w0),
  .clk_in(w1)
 );
endmodule

module v435b29_vac7386 #(
 parameter N = 0
) (
 input clk_in,
 output clk_out
);
 //-- Number of bits of the prescaler
 //parameter N = 22;
 
 //-- divisor register
 reg [N-1:0] divcounter;
 
 //-- N bit counter
 always @(posedge clk_in)
   divcounter <= divcounter + 1;
 
 //-- Use the most significant bit as output
 assign clk_out = divcounter[N-1];
endmodule

module v11a6f4 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v11a6f4_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

module v11a6f4_vf4938a (
 input a,
 input b,
 output c
);
 // AND logic gate
 
 assign c = a & b;
endmodule

module v2fa1b5 (
 input v0e28cb,
 input v3ca442,
 output vcbab45
);
 wire w0;
 wire w1;
 wire w2;
 assign w0 = v0e28cb;
 assign w1 = v3ca442;
 assign vcbab45 = w2;
 v2fa1b5_vf4938a vf4938a (
  .a(w0),
  .b(w1),
  .c(w2)
 );
endmodule

module v2fa1b5_vf4938a (
 input a,
 input b,
 output c
);
 // OR logic gate
 
 assign c = a | b;
endmodule

module v32200d (
 input v0e28cb,
 output vcbab45
);
 wire w0;
 wire w1;
 assign w0 = v0e28cb;
 assign vcbab45 = w1;
 v32200d_vd54ca1 vd54ca1 (
  .a(w0),
  .c(w1)
 );
endmodule

module v32200d_vd54ca1 (
 input a,
 output c
);
 // NOT logic gate
 
 assign c = ~ a;
endmodule

module v27b161 (
 input vdd1857,
 input [25:0] ve87cf9,
 input [7:0] v5f213f,
 input v86d7a2,
 input v0d69f5,
 input [5:0] v508a28,
 input [5:0] v26d0c3,
 output [25:0] v16dd7b,
 output [7:0] ve94c8f,
 output v52218c
);
 wire w0;
 wire [0:25] w1;
 wire w2;
 wire [0:25] w3;
 wire w4;
 wire w5;
 wire [0:10] w6;
 wire [0:5] w7;
 wire [0:5] w8;
 wire [0:7] w9;
 wire [0:7] w10;
 wire w11;
 wire [0:10] w12;
 wire [0:10] w13;
 wire [0:10] w14;
 wire [0:25] w15;
 wire [0:25] w16;
 wire [0:7] w17;
 wire [0:7] w18;
 wire w19;
 wire w20;
 wire w21;
 wire w22;
 assign w0 = vdd1857;
 assign v16dd7b = w1;
 assign w2 = vdd1857;
 assign w3 = ve87cf9;
 assign w4 = vdd1857;
 assign w5 = v0d69f5;
 assign w7 = v508a28;
 assign w8 = v26d0c3;
 assign w9 = v5f213f;
 assign w11 = vdd1857;
 assign ve94c8f = w18;
 assign w19 = v86d7a2;
 assign v52218c = w20;
 assign w21 = v86d7a2;
 assign w2 = w0;
 assign w4 = w0;
 assign w4 = w2;
 assign w11 = w0;
 assign w11 = w2;
 assign w11 = w4;
 assign w13 = w6;
 assign w17 = w10;
 assign w21 = w19;
 v27b161_v1d8a4b v1d8a4b (
  .waddr(w6),
  .posx_tab(w7),
  .posy_tab(w8)
 );
 vff2ebf vd527df (
  .va1d85e(w2),
  .v5a8513(w5),
  .vf0a2de(w6),
  .v5943db(w9),
  .v002f62(w10),
  .v7b2f9b(w14)
 );
 v27b161_v71b70f v71b70f (
  .px_clk(w11),
  .RGBStr_i(w15),
  .RGBStr_o(w16)
 );
 v9ba9b8 v581fe7 (
  .vdd1857(w0),
  .v16dd7b(w1),
  .v65b417(w10),
  .ve87cf9(w16)
 );
 v27b161_va5fbe0 va5fbe0 (
  .raddr_video(w12),
  .raddr_control(w13),
  .raddr(w14),
  .select(w21)
 );
 v27b161_v30877f v30877f (
  .RGBStr_i(w3),
  .px_clk(w4),
  .raddr(w12),
  .RGBStr_o(w15),
  .busy(w22)
 );
 v27b161_v65095a v65095a (
  .sprite_i(w17),
  .sprite_o(w18),
  .get(w19),
  .ready(w20),
  .busy(w22)
 );
endmodule

module v27b161_v1d8a4b (
 input [5:0] posx_tab,
 input [5:0] posy_tab,
 output [10:0] waddr
);
 // Calcula la dirección en el tablero.
 //
 assign waddr = posy_tab*40 + posx_tab;
endmodule

module v27b161_v71b70f (
 input px_clk,
 input [25:0] RGBStr_i,
 output [25:0] RGBStr_o
);
 reg [25:0] RGBStr_o;
 
 always @(px_clk)
 begin
     RGBStr_o <= RGBStr_i;
 end
endmodule

module v27b161_va5fbe0 (
 input [10:0] raddr_video,
 input [10:0] raddr_control,
 input select,
 output [10:0] raddr
);
 assign raddr = (select) ? raddr_control : raddr_video;
endmodule

module v27b161_v30877f (
 input px_clk,
 input [25:0] RGBStr_i,
 output [25:0] RGBStr_o,
 output busy,
 output [10:0] raddr
);
 `define YC 12:3			// Y Coordinate
 `define XC 22:13		// X Coordinate
 
 reg [10:0] raddr;
 reg [25:0] RGBStr_o;
 reg busy;
 
 always @(px_clk)
 begin
     RGBStr_o <= RGBStr_i;
     
     if (RGBStr_i[0:0])      // Visible pixel.
     begin
         raddr <= RGBStr_i[12:7]*40 + RGBStr_i[22:17];
         busy <= 1;
     end
     else
     begin
         busy <= 0;
     end
 end
endmodule

module v27b161_v65095a (
 input [7:0] sprite_i,
 input get,
 input busy,
 output [7:0] sprite_o,
 output ready
);
 reg [7:0] sprite_o;
 reg ready;
 
 always @(negedge busy)
 begin
     if (get)
     begin
         sprite_o <= sprite_i;
         ready <= 1'b1;
     end
     else
         ready <= 1'b0;
 end
endmodule

module vff2ebf #(
 parameter va63311 = "inittab.list"
) (
 input va1d85e,
 input [10:0] v7b2f9b,
 input [7:0] v5943db,
 input v5a8513,
 input [10:0] vf0a2de,
 output [7:0] v002f62
);
 localparam p4 = va63311;
 wire w0;
 wire w1;
 wire [0:10] w2;
 wire [0:10] w3;
 wire [0:7] w5;
 wire [0:7] w6;
 assign w0 = va1d85e;
 assign w1 = v5a8513;
 assign w2 = vf0a2de;
 assign w3 = v7b2f9b;
 assign w5 = v5943db;
 assign v002f62 = w6;
 vff2ebf_v629585 #(
  .TABFILE(p4)
 ) v629585 (
  .px_clk(w0),
  .write_en(w1),
  .waddr(w2),
  .raddr(w3),
  .din(w5),
  .dout(w6)
 );
endmodule

module vff2ebf_v629585 #(
 parameter TABFILE = 0
) (
 input px_clk,
 input [10:0] raddr,
 input [7:0] din,
 input write_en,
 input [10:0] waddr,
 output [7:0] dout
);
 //@include TableRAM.v
 
 TableRAM
 #(
 .FILE(TABFILE)
 )
 TableRAM_01
 (
     px_clk,
     din,
     write_en,
     waddr,
     raddr,
     dout
 );
endmodule

module v9ba9b8 (
 input vdd1857,
 input [25:0] ve87cf9,
 input [7:0] v65b417,
 output [25:0] v16dd7b
);
 wire w0;
 wire w1;
 wire [0:3] w2;
 wire [0:25] w3;
 wire [0:25] w4;
 wire [0:7] w5;
 wire w6;
 wire w7;
 wire [0:11] w8;
 wire [0:25] w9;
 wire [0:25] w10;
 assign w0 = vdd1857;
 assign w1 = vdd1857;
 assign w3 = ve87cf9;
 assign v16dd7b = w4;
 assign w5 = v65b417;
 assign w6 = vdd1857;
 assign w7 = vdd1857;
 assign w1 = w0;
 assign w6 = w0;
 assign w6 = w1;
 assign w7 = w0;
 assign w7 = w1;
 assign w7 = w6;
 v9ba9b8_v2ed08c v2ed08c (
  .pixel(w2),
  .RGBStr_o(w4),
  .px_clk(w6),
  .RGBStr_i(w10)
 );
 v9ba9b8_vd99fae vd99fae (
  .px_clk(w7),
  .RGBStr_i(w9),
  .RGBStr_o(w10)
 );
 vc2642c vddfecb (
  .v2ff132(w0),
  .v80a7ca(w2),
  .ve1a960(w8)
 );
 v9ba9b8_v269c31 v269c31 (
  .px_clk(w1),
  .RGBStr_i(w3),
  .sprite(w5),
  .addr(w8),
  .RGBStr_o(w9)
 );
endmodule

module v9ba9b8_v2ed08c (
 input px_clk,
 input [3:0] pixel,
 input [25:0] RGBStr_i,
 output [25:0] RGBStr_o
);
 `define RGB 25:23		// Pixel RGB (1:1:1)
 `define Active 0:0 		// ActiveVideo
 
 reg [25:0] RGBStr_o;
 
 always @(px_clk)
 begin
     RGBStr_o <= RGBStr_i;
     if (RGBStr_i[`Active])
         RGBStr_o[`RGB] <= pixel[2:0];  // Only three pixels for color.
     else
         RGBStr_o[`RGB] <= 3'b000;
 end
 
endmodule

module v9ba9b8_vd99fae (
 input px_clk,
 input [25:0] RGBStr_i,
 output [25:0] RGBStr_o
);
 reg [25:0] RGBStr_o;
 
 always @(px_clk)
 begin
     RGBStr_o <= RGBStr_i;
 end
endmodule

module v9ba9b8_v269c31 (
 input px_clk,
 input [25:0] RGBStr_i,
 input [7:0] sprite,
 output [11:0] addr,
 output [25:0] RGBStr_o
);
 //@include TestCodeA.v
 
 TestCodeA
 TestCodeA_01
 (
     px_clk,
     RGBStr_i,
     sprite,
     addr,
     RGBStr_o
 );
endmodule

module vc2642c #(
 parameter vbc1e63 = "pacman.list"
) (
 input v2ff132,
 input [11:0] ve1a960,
 output [3:0] v80a7ca
);
 localparam p0 = vbc1e63;
 wire [0:3] w1;
 wire w2;
 wire [0:11] w3;
 assign v80a7ca = w1;
 assign w2 = v2ff132;
 assign w3 = ve1a960;
 vc2642c_vc5d4e1 #(
  .BMPFILE(p0)
 ) vc5d4e1 (
  .pixel(w1),
  .clk(w2),
  .addr(w3)
 );
endmodule

module vc2642c_vc5d4e1 #(
 parameter BMPFILE = 0
) (
 input clk,
 input [11:0] addr,
 output [3:0] pixel
);
 //@include SpriteROM.v
 
 SpriteROM
 #(
     .FILE(BMPFILE)
 )
 SpriteROM_01
 (
     clk,    // System clock.          
     addr,   // Address in ROM.
     pixel   // Pixel in address.        
 );
endmodule

module v4ee1dc (
 input v9f94eb,
 input v3c7b5b,
 input [7:0] v4251e6,
 output v38a546,
 output vb37ae4
);
 wire [0:7] w0;
 wire w1;
 wire w2;
 wire [0:9] w3;
 wire w4;
 wire w5;
 wire w6;
 wire w7;
 wire w8;
 wire w9;
 wire w10;
 wire w11;
 wire [0:7] w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 wire w17;
 wire w18;
 wire w19;
 assign w7 = v9f94eb;
 assign w8 = v9f94eb;
 assign w9 = v9f94eb;
 assign w10 = v9f94eb;
 assign vb37ae4 = w11;
 assign w12 = v4251e6;
 assign w13 = v3c7b5b;
 assign v38a546 = w17;
 assign w19 = v9f94eb;
 assign w8 = w7;
 assign w9 = w7;
 assign w9 = w8;
 assign w10 = w7;
 assign w10 = w8;
 assign w10 = w9;
 assign w18 = w5;
 assign w19 = w7;
 assign w19 = w8;
 assign w19 = w9;
 assign w19 = w10;
 v239306 vd703dd (
  .v02ed6f(w0),
  .va31c0f(w8),
  .va3ae6b(w12),
  .vc21fb3(w14)
 );
 vb734f6 v3259a0 (
  .v9fb85f(w4)
 );
 vb8d6b2 vf26bc1 (
  .v6be12a(w0),
  .vb4b52a(w1),
  .vab11c1(w2),
  .v3a391b(w3)
 );
 vfec7ff v1df2d0 (
  .v9fb85f(w1)
 );
 vb734f6 vf0ee73 (
  .v9fb85f(w2)
 );
 vb4ce62 v19d8c9 (
  .va56954(w5),
  .vd8476e(w7),
  .v67cccc(w15)
 );
 v3c8460 v56475f (
  .v942550(w3),
  .va19be7(w4),
  .vc6dce5(w5),
  .v86b30f(w6),
  .v8ac4a3(w9),
  .v3c4344(w16)
 );
 v5d56f1 v9012ed (
  .v74a653(w6),
  .vd7ce19(w10),
  .vc6ae1f(w11)
 );
 v9a8598 v517ead (
  .v86f5ff(w13),
  .v174601(w14),
  .v890bc7(w15),
  .vdd8a83(w16),
  .va07a39(w17),
  .v7f4aeb(w18),
  .v1963e6(w19)
 );
endmodule

module vb734f6 (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 vb734f6_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

module vb734f6_vb2eccd (
 output q
);
 //-- Bit constante a 1
 assign q = 1'b1;
 
 
endmodule

module vb8d6b2 (
 input [7:0] v6be12a,
 input vb4b52a,
 input vab11c1,
 output [9:0] v3a391b
);
 wire [0:7] w0;
 wire w1;
 wire w2;
 wire [0:9] w3;
 assign w0 = v6be12a;
 assign w1 = vb4b52a;
 assign w2 = vab11c1;
 assign v3a391b = w3;
 vb8d6b2_v591cfe v591cfe (
  .i2(w0),
  .i1(w1),
  .i0(w2),
  .o(w3)
 );
endmodule

module vb8d6b2_v591cfe (
 input [7:0] i2,
 input i1,
 input i0,
 output [9:0] o
);
 assign o = {i2,i1,i0};
 
endmodule

module vfec7ff (
 output v9fb85f
);
 wire w0;
 assign v9fb85f = w0;
 vfec7ff_vb2eccd vb2eccd (
  .q(w0)
 );
endmodule

module vfec7ff_vb2eccd (
 output q
);
 //-- Bit constante a 0
 assign q = 1'b0;
 
 
endmodule

module vb4ce62 (
 input vd8476e,
 input v67cccc,
 output va56954
);
 wire w0;
 wire w1;
 wire w2;
 assign va56954 = w0;
 assign w1 = vd8476e;
 assign w2 = v67cccc;
 vb4ce62_v4570a9 v4570a9 (
  .clk_out(w0),
  .clk(w1),
  .ena(w2)
 );
endmodule

module vb4ce62_v4570a9 (
 input clk,
 input ena,
 output clk_out
);
 
 //-- Constants for obtaining standard BAURATES:
 `define B115200 139  //-- 103 for TX, 104 for RX
 
 `define B57600  208
 `define B38400  313
 
 `define B19200  625
 `define B9600   1250
 `define B4800   2500
 `define B2400   5000
 `define B1200   10000
 `define B600    20000
 `define B300    40000
 
 
 //-- Default Baudrate
 localparam BAUDRATE = `B115200;
 
 //-- Number of bits needed for storing the baudrate divisor
 localparam N = $clog2(BAUDRATE);
 
 //-- Counter for implementing the divisor (it is a BAUDRATE module counter)
 //-- (when BAUDRATE is reached, it start again from 0)
 reg [N-1:0] divcounter = 0;
 
 always @(posedge clk)
 
   if (ena)
     //-- Normal working: counting. When the maximum count is reached, it starts from 0
     divcounter <= (divcounter == BAUDRATE - 1) ? 0 : divcounter + 1;
   else
     //-- Counter fixed to its maximum value
     //-- When it is resumed it start from 0
     divcounter <= BAUDRATE - 1;
 
 //-- The output is 1 when the counter is 0, if clk_ena is active
 //-- It is 1 only for one system clock cycle
 assign clk_out = (divcounter == 0) ? ena : 0;
 
 
 
endmodule

module v3c8460 (
 input v8ac4a3,
 input v3c4344,
 input vc6dce5,
 input [9:0] v942550,
 input va19be7,
 output v86b30f
);
 wire w0;
 wire w1;
 wire w2;
 wire w3;
 wire [0:9] w4;
 wire w5;
 assign v86b30f = w0;
 assign w1 = v3c4344;
 assign w2 = vc6dce5;
 assign w3 = va19be7;
 assign w4 = v942550;
 assign w5 = v8ac4a3;
 v3c8460_vfa7d39 vfa7d39 (
  .ser_out(w0),
  .load(w1),
  .clk_baud(w2),
  .ser_in(w3),
  .data(w4),
  .clk(w5)
 );
endmodule

module v3c8460_vfa7d39 (
 input clk,
 input load,
 input clk_baud,
 input [9:0] data,
 input ser_in,
 output ser_out
);
 reg [9:0] shifter = 10'b11_1111_1111;
 
 always @(posedge clk)
   //-- Load mode
   if  (load == 1)
     shifter <= data;
 
   //-- Shift mode
   else if (load == 0 && clk_baud == 1)
     shifter <= {ser_in, shifter[9:1]};
     
 //-- Serial output (less significant bit)    
 assign ser_out = shifter[0];
endmodule

module v9a8598 (
 input v1963e6,
 input v7f4aeb,
 input v86f5ff,
 output va07a39,
 output vdd8a83,
 output v890bc7,
 output v174601
);
 wire [0:1] w0;
 wire w1;
 wire w2;
 wire [0:3] w3;
 wire w4;
 wire w5;
 wire [0:1] w6;
 wire [0:1] w7;
 wire [0:1] w8;
 wire [0:1] w9;
 wire [0:1] w10;
 wire w11;
 wire w12;
 wire w13;
 wire w14;
 wire w15;
 wire w16;
 assign va07a39 = w1;
 assign w4 = v86f5ff;
 assign w5 = v86f5ff;
 assign w11 = v7f4aeb;
 assign vdd8a83 = w12;
 assign v890bc7 = w13;
 assign v174601 = w14;
 assign w15 = v1963e6;
 assign w16 = v1963e6;
 assign w5 = w4;
 assign w7 = w6;
 assign w8 = w6;
 assign w8 = w7;
 assign w9 = w6;
 assign w9 = w7;
 assign w9 = w8;
 assign w10 = w6;
 assign w10 = w7;
 assign w10 = w8;
 assign w10 = w9;
 assign w12 = w2;
 assign w16 = w15;
 v0a31bf v461b39 (
  .v43dc18(w2),
  .v4dac78(w3),
  .v844cf1(w11),
  .v7b4936(w16)
 );
 v9a8598_v98ee37 v98ee37 (
  .i(w0),
  .o(w6),
  .clk(w15)
 );
 v9a8598_v1f1e3e v1f1e3e (
  .start(w4),
  .state(w9),
  .ld_id(w14)
 );
 v9a8598_ve80bb6 ve80bb6 (
  .ready(w1),
  .state(w7)
 );
 v9a8598_v3e7d77 v3e7d77 (
  .load(w2),
  .state(w10)
 );
 v9a8598_v05458e v05458e (
  .state(w8),
  .baud_en(w13)
 );
 v9a8598_vd2db0a vd2db0a (
  .next_state(w0),
  .bitc(w3),
  .start(w5),
  .state(w6)
 );
endmodule

module v9a8598_v98ee37 (
 input clk,
 input [1:0] i,
 output [1:0] o
);
 reg [1:0] o = 0;
 
 //-- Transition between states
 always @(posedge clk)
     o <= i;
 
endmodule

module v9a8598_v1f1e3e (
 input [1:0] state,
 input start,
 output ld_id
);
 //-- Load the input-data register
 //-- The data is only loaded when in the IDLE state
 //-- and the start signal is set
 assign ld_id = (start && state==2'b00);
 
endmodule

module v9a8598_ve80bb6 (
 input [1:0] state,
 output ready
);
 localparam IDLE  = 0;  //-- Idle state
 
 assign ready = (state == IDLE);
 
endmodule

module v9a8598_v3e7d77 (
 input [1:0] state,
 output load
);
 localparam START  = 1;  //-- Start transmission
 assign load = (state == START);
 
endmodule

module v9a8598_v05458e (
 input [1:0] state,
 output baud_en
);
 localparam IDLE  = 0;  //-- Idle staten
 assign baud_en = (state != IDLE);
 
endmodule

module v9a8598_vd2db0a (
 input [1:0] state,
 input [3:0] bitc,
 input start,
 output [1:0] next_state
);
 
 //-- fsm states
 localparam IDLE  = 0;  //-- Idle state
 localparam START = 1;  //-- Start transmission
 localparam TRANS = 2;  //-- Transmitting data
 
 //-- Registers for storing the states
 reg [1:0] next_state;
 
 
 //-- Control signal generation and next states
 always @(*) begin
 
   case (state)
 
     //-- Idle state
     //-- Remain in this state until start is 1
     IDLE:
       if (start == 1)
         next_state = START;
       else
         next_state = IDLE;
 
     //-- 1 cycle long
     //-- turn on the baudrate generator and the load the shift register
     START:
       next_state = TRANS;
 
     //-- Stay here until all the bits have been sent
     TRANS:
       if (bitc == 11)
         next_state = IDLE;
       else
         next_state = TRANS;
 
     default: begin
     end
 
   endcase
 end
 
endmodule

module v0a31bf (
 input v7b4936,
 input v43dc18,
 input v844cf1,
 output [3:0] v4dac78
);
 wire [0:3] w0;
 wire w1;
 wire w2;
 wire w3;
 assign v4dac78 = w0;
 assign w1 = v7b4936;
 assign w2 = v43dc18;
 assign w3 = v844cf1;
 v0a31bf_vf1519a vf1519a (
  .bitc(w0),
  .clk(w1),
  .rst(w2),
  .ena(w3)
 );
endmodule

module v0a31bf_vf1519a (
 input clk,
 input rst,
 input ena,
 output [3:0] bitc
);
 reg [3:0] _bitc = 0;
 
 always @(posedge clk)
   if (rst)
     _bitc <= 0;
   else if (rst == 0 && ena == 1)
     _bitc <= _bitc + 1;
     
 assign bitc = _bitc;
endmodule

module main_veaf5aa (
 input rcv,
 input [7:0] data,
 output [7:0] control
);
 reg [7:0] control;
 
 always @(posedge rcv)
 begin
     //control <= 8'd0;
     case (data)
                  8'h6A: control[5] <= 1'b1; // j - left
                  8'h6C: control[4] <= 1'b1; // l - right
                  8'h69: control[3] <= 1'b1; // i - up
                  8'h6B: control[2] <= 1'b1; // k - down
                  8'h61: control[1] <= 1'b1; // a - btn1
                  8'h73: control[0] <= 1'b1; // s - btn2
                  8'h67: control[1:0] <=  2'b11; // g - guardar
                default: control <= 8'd0;
 
     endcase
 end
endmodule
